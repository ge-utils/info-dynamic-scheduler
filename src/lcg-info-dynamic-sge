#!/usr/bin/perl -w
#
# Sun Grid Engine information provider for LCG.
# Originally based on the existing LCG PBS information provider,
# but now bears very little resemblence!

# If you modify this script locally,  please append a suitable suffix
# to this version string

use constant VERSION => '0.11';

# See LICENSE for licensing information.
# See CREDITS for attributions.
# See AUTHORS for information about the maintainers

# --- Compiler directives ------------------------------------------------

use strict;
use warnings;
use XML::Simple;

use Getopt::Long;
use Time::Local;
use IO::File;
use IO::Pipe;

use Carp;

# --- Globals ------------------------------------------------------------

# Do not change the values here

# All of the values that are meant to be changeable should be
# settable on either the command line and/or in the config file

my ( %CONFIG );

# Default CONFIG File Location
# This CONFIG file is only read if 
# - It exists
# - We didn't find a config file specified on the command line
# - The --disable_default_config_file option wasn't specified
my $DEFAULT_CONFIG_FILE         = '/etc/sge-jobmanager/info-reporter.conf';

# Path to static LDIF file
$CONFIG{'ldif_file'}            = '/opt/lcg/var/gip/ldif/static-file-CE.ldif';

# Path to SGE jobmanager virtual queue mapping configuration file.
$CONFIG{'vqueue_file'}          = '/etc/sge-jobmanager/vqueues.conf';

# Path to file defining current cluster state.
# (One of 'Production', 'Draining', 'Queueing', 'Closed')
$CONFIG{'state_file'}           = '/etc/sge-jobmanager/cluster.state';

# Path to various SGE commands
# IF not set in the config, the default values are calculated after the
# config has been parsed as they are based on other config values
$CONFIG{'qselect_command'}      = undef;
$CONFIG{'qstat_command'}        = undef;
$CONFIG{'qconf_command'}        = undef;

# Date command... for parsing dates that we don't recognise
$CONFIG{'date_command'}         = '/bin/date';

# Regexp values for matching/excluding queues to be considered
$CONFIG{'queue_include_regexp'} = undef;
$CONFIG{'queue_exclude_regexp'} = undef;

# Regexp values for matching/excluding users to be considered
$CONFIG{'user_include_regexp'} = undef;
$CONFIG{'user_exclude_regexp'} = undef;

# Estimated efficiency of a typical job... for converting between wallclock & cputime
$CONFIG{'job_efficiency'}      = 0.9;

# Max Wallclock time for a job if one can't be determined
# If set in the config file or command line, the value is passed through
# timeValueToSeconds before being assigned
# FIXME:  This could perhaps be picked up from the "qconf -sconf" default_duration
$CONFIG{'default_duration'}    = 7 * 24 * 60 * 60;

$CONFIG{'passwd_file'}  = undef;
$CONFIG{'group_file'}  = undef;

# The following values can only be set on the command line

# Variable to control debugging output
my $DEBUG;

# Time at which the input data for the command was generated
# Defaults to now,  but can be overridden if required
my ( $TIME ) = time;

# MAXINT value
my ( $MAX_INT32 ) = ( 1 << 31 ) - 1;

# Filename to store captured debugging info
$CONFIG{'capture_file'}        = undef;

# IO::File handle of file being used to capture debugging info
my ( $CAPTURE_FILE );
my ( $CAPTURE_INDEX ) = '0000';

# Resource Contraints for queues/jobs

my %CONSTRAINTS 
	= ( 'h_rt'            => \&checkTimeConstraint,
	    's_rt'            => \&checkTimeConstraint,
	    'h_cpu'           => \&checkTimeConstraint,
	    's_cpu'           => \&checkTimeConstraint,
	    'max_wall_time'   => \&checkTimeConstraint,
	    'max_cpu_time'    => \&checkTimeConstraint,
	    'queue'           => \&checkQueueConstraint,
	   );


# Contraints that should be mapped onto queue values
my %RSL_TO_GLUE
	= (
	   "max_wall_time" => "GlueCEPolicyMaxWallClockTime",
	   "h_rt"          => "GlueCEPolicyMaxWallClockTime",
	   "s_rt"          => "GlueCEPolicyMaxWallClockTime",
	   "max_cpu_time"  => "GlueCEPolicyMaxCPUTime",
	   "h_cpu"         => "GlueCEPolicyMaxCPUTime",
	   "s_cpu"         => "GlueCEPolicyMaxCPUTime",
	   );

# Factor by which to multiply the value given in the SGE 
# JobManager configuration file.

my %RSL_TO_GLUE_MULTIPLIER
	= (
	   "h_rt"          => 1/60,
	   "s_rt"          => 1/60,
	   "h_cpu"         => 1/60,
	   "s_cpu"         => 1/60,
	   );

# Fields that are of interest when printing per VO information

my ( @VO_INTERESTING_KEYS )
	= qw(  GlueCEStateEstimatedResponseTime
	       GlueCEStateFreeJobSlots
	       GlueCEStateRunningJobs
	       GlueCEStateTotalJobs
	       GlueCEStateWaitingJobs
	       GlueCEStateWorstResponseTime
	       );

my ( %NUMERIC_KEYS )
	= map( ( $_ => 1 ),
			qw(  GlueCEStateEstimatedResponseTime
	       			GlueCEStateFreeJobSlots
	       			GlueCEStateRunningJobs
	       			GlueCEStateTotalJobs
	       			GlueCEStateWaitingJobs
	       			GlueCEStateWorstResponseTime
				GlueCEStateFreeCPUs
	       			) );


my ( %VO_FROM_LOGIN, %VO_FROM_GROUP );

# --- Process command line then validate the environment

&processCommandLine();

# --- Read in passwd and group files if required

my ( $GETPWNAM, %LOGINS );

if ( $CONFIG{'passwd_file'} ) {
	&populate_fake( \%LOGINS, $CONFIG{'passwd_file'}, 0 );
	$GETPWNAM = \&getpwnam_fake;
} else {
	$GETPWNAM = \&getpwnam_sys;
}

my ( $GETGRGID, %GROUPS );

if ( $CONFIG{'group_file'} ) {
	&populate_fake( \%GROUPS, $CONFIG{'group_file'}, 2 );
	$GETGRGID = \&getgrgid_fake;
} else {
	$GETGRGID = \&getgrgid_sys;
}

# --- Validation of environment

# Some default values are also set here if they are dependant on other
# configuration values

foreach ( qw( SGE_ROOT SGE_ARCH ) ) {
	die "$0: $_ is not set\n"
		unless defined( $ENV{$_} );
}

$ENV{'SGE_CELL'} = 'default' unless defined( $ENV{'SGE_CELL'} );

foreach ( qw( qconf qstat qselect ) ) {
	$CONFIG{$_."_command"} = $ENV{"SGE_ROOT"}.'/bin/'.$ENV{"SGE_ARCH"}.'/'.$_
		unless defined( $CONFIG{$_."_command"} );
}

if ( $CONFIG{'capture_file'} ) {
	if ( -f $CONFIG{'capture_file'} ) {
		warn "ignoring capture_file as $CONFIG{'capture_file'} already exists\n";
	} elsif ( ! ( $CAPTURE_FILE = new IO::File( $CONFIG{'capture_file'}, "w", 0600 ) ) ) {
		warn "cannot open $CONFIG{'capture_file'}: $!\n";
	} else {
		$CAPTURE_FILE->autoflush(1);
		my $i = &setupCaptureInfo( 'time' );
		&captureInfo( $i, $TIME );

		$i = &setupCaptureInfo( 'version' );
		&captureInfo( $i, VERSION );

		$i = &setupCaptureInfo( 'config' );
		
		foreach ( sort keys %CONFIG ) {
			&captureInfo( $i, "$_=$CONFIG{$_}" ) if defined( $CONFIG{$_} );
		}

		$i = &setupCaptureInfo( 'environment' );
		
		foreach ( sort keys %ENV ) {
			&captureInfo( $i, "$_=$ENV{$_}" ) if defined( $ENV{$_} );
		}
	}
}

# FIXME: This should not be global.
# FIXME: A better mechanism would be to specify a deadline by which the
#	 cluster must be closed.  In this way, individual queues could
#	 be taken offline automatically as the deadline approaches.
# FIXME: We may also be able to pick up on some of the state settings
#        automatically based on the states of the underlying SGE queues.
#        This is how things are done with PBS/Torque... however the SGE queue
#        states don't have an obvious equivalent to the "Draining" state
my $clusterstate	= "Production";

# Lookup state of cluster.
my $statefile = new IO::File( $CONFIG{'state_file'}, "r" );
if ( $statefile ) {
	my $capture_idx = &setupCaptureInfo( 'state_file' ) if $CAPTURE_FILE;

	while( defined( $_ = $statefile->getline ) ) {
		&captureInfo( $capture_idx, $_ ) if $CAPTURE_FILE;

		$clusterstate = $1
			if /^\s*(Production|Queueing|Draining|Closed)\s*$/;
	}
	$statefile->close;
} else {
	warn "Unable to open cluster state file $CONFIG{'state_file'}: $!\nAssuming cluster is in Production\n";
}

# --- Function definitions -----------------------------------------------

# Process the command line arguments
# Refers to @ARGV

sub processCommandLine {
	GetOptions( 'config_file=s'                => sub { \&parseConfigFile( $_[1] ) },
		    'disable_default_config_file'  => sub { $DEFAULT_CONFIG_FILE = undef; },
		    'setenv=s%'                    => \%ENV,
		    'debug'                        => \$DEBUG,
		    'time=i'                       => \$TIME,
		    map { ( "$_=s" => \&processConfigEntry ) } ( keys %CONFIG )
		    ) or die "$0: aborting due to unrecognised command line option(s)\n";
	
	foreach ( @ARGV ) {
		if ( /^.+\.conf$/ )     { &parseConfigFile( $_ ); }
		elsif ( /^.+\.ldif$/ )  { &processConfigEntry( 'ldif_file', $_ ); }
		else {
			die "$0: unrecognised command line option: $_\n";
		}
	}
	
	&parseConfigFile( $DEFAULT_CONFIG_FILE )
		if defined( $DEFAULT_CONFIG_FILE ) && -f $DEFAULT_CONFIG_FILE;
}

# Given the path to the local configuration file, extracts all of the 
# configuration information we're interested in.

sub parseConfigFile($) {
	my ($configpath) = shift;	# Path to the configuration file.
    
	# We have been given a config file so don't try reading the default one
	$DEFAULT_CONFIG_FILE = undef;

	# Open the file.
	open(CONFIG, $configpath)
		or die "Unable to open configuration file $configpath: $!";
	
	# For every config file entry:
	while(<CONFIG>) {
		# Trim comments
		s/\#.*//;
		
		# Trim leading/trailing whitespace
		s/^\s+//; s/\s+$//;

		# Skip blank links
		next if /^$/;

		# Split into key/value pair
		# Allowing formats:
		#    key value
		#    key=value
		#    key = value
		# "key" is case insignificant
		# "value" is optionally enclosed in quotes,  though this doesn't currently
		# make any difference as to how the value is interpreted   (other than
		# allowing the possibility of leading/trailing whitespace)

		my ( $k, $v ) = split( /[\s\=]+/, $_, 2 );

		$k = "\L$k";
		$v =~ s/^\"(.*)\"$/$1/;

		&processConfigEntry( $k, $v );
	}

	close( CONFIG );
}
		

# Process individual configfile/commandline entry
# This is called from either processConfig or by Getopt::Long::GetOptions

sub processConfigEntry($$) {
	my ( $k, $v ) = @_;

	if    ( $k eq 'default_duration'           ) { $CONFIG{$k} = timeValueToSeconds( $v ); }
	elsif ( $k =~ /^sge_(root|arch|cell)$/     ) { $ENV{"\U$k"} = $v; }
	elsif ( $k eq 'setenv' 
		&& $v =~ /^([^=]+)\=(.*)$/         ) { $ENV{$1} = $2; }
	elsif ( $k eq 'debug_time'                 ) { $TIME = $v; }
	elsif ( $k eq 'group'
		&& $v =~ /^([^=]+)\=(.*)$/         ) { $VO_FROM_GROUP{$1} = $2; }
	elsif ( $k eq 'login'
		&& $v =~ /^([^=]+)\=(.*)$/         ) { $VO_FROM_LOGIN{$1} = $2; }
	elsif ( exists( $CONFIG{$k} )              ) { $CONFIG{$k} = $v; }
	else {
		die "unrecognised configuration entry: $k=$v";
	}
} 

# Convert dates as produced by "qstat -xml" into seconds since the unix epoch

sub parse_date($) {
	my ($date) = shift;

        # 12/05/2006 20:58:33 pre  6.0u6   (seems to be MM/DD/YYY)    
	# 2006-12-05T20:58:33 post 6.0u9   (not sure exactly which version changed the format)

	if ( $date =~ m~^(\d{4})\-(\d{2})\-(\d{2})T(\d{2})\:(\d{2})\:(\d{2})$~ ) {
		timelocal( $6, $5, $4, $3, $2 - 1, $1 );
	} elsif ( $date =~ m~^(\d{2})/(\d{2})/(\d{4})\s+(\d{2})\:(\d{2})\:(\d{2})$~ ) {
		timelocal( $6, $5, $4, $2, $1 - 1, $3 );
	} else {
		warn "Unrecognised date returned by queuing system: \"$date\"\n";
		my ( $tstamp ) = `$CONFIG{'date_command'} -d "$date" "+%s"`; 
		chomp $tstamp;
		$tstamp;
	}
}

# Capture information into a file to allow later debugging

sub setupCaptureInfo {
	&captureInfo( ++$CAPTURE_INDEX, @_ );
	$CAPTURE_INDEX;
}

sub captureInfo {
	my $index = shift @_;

	$CAPTURE_FILE->print( "$index:@_\n" );
}

# Given the path to the local static LDIF information file, extract
# a list of distinguished names that we should report information for
#
# Each DN will be of the form:
#          dn: GlueCEUniqueID=$TARGET
# or       dn: GlueVOViewLocalID=$VO,GlueCEUniqueID=$TARGET
#
# We prime the "queue" hash and return an array of tuples consisting of:
#        [ dn, queue, vo ]

sub lookupDNs($$) {
	my ($ldifpath,$queueref) = @_;	# Path to the LDIF file & ref for queue hash
	my (@DN);			# Result list

	# Open the file.
	my $ldifdata = new IO::File( $ldifpath, "r" )
		or die "Unable to open static LDIF information file $ldifpath: $!\n";
	
	my $capture_idx = &setupCaptureInfo( 'ldiffile' ) if $CAPTURE_FILE;

	# For every line:
	while( defined( $_ = $ldifdata->getline ) ) {
		&captureInfo( $capture_idx, $_ ) if $CAPTURE_FILE;

		# If the line contains a DN definition for a queue
		if ( /^dn\:\s*((?:GlueVOViewLocalID\=([^\s\,]+)\,\s*)?GlueCEUniqueID\=\S+\/(?:jobmanager|blah|cream)\-\w*sge\w*\-([^\,]+)\,.+)$/ ) {
			# We have found an entry that we are interested in
			my ( $dn        ) = $1;
			my ( $vo        ) = $2;
			my ( $queuename ) = $3;
			
			push( @DN, [ $dn, $queuename, $vo ] );
			
			if ( defined( $vo ) ) {
				push( @{$queueref->{$queuename}->{"volist"}}, $vo );
			} else {
				$queueref->{$queuename}->{"dn"} = $dn;
			}
		} elsif ( /^dn\:/ ) {
			die "Found malformed queue entry \"$_\" in the file \"".$CONFIG{'ldif_file'}."\"";
		}
	}
	
	$ldifdata->close;

	@DN;
}

# This function will lookup the local SGE version number.
# It works by running the command 'qstat -help'; the first line of the output
# of this command will contain the local version number.  eg:
# 	SGEEE 5.3p3
# 	SGE 6.0u1
# However, we just need the version number -- so we strip off the first word
# from this string before returning.

sub lookupSGEVersion() {
	my $qstatdata = new IO::Pipe;
	my ( @command ) = ( $CONFIG{'qstat_command'}, '-help' );

	my $capture_idx = &setupCaptureInfo( 'pipe', @command )	if $CAPTURE_FILE;

	$qstatdata->reader( @command )
		or die "Unable to lookup SGE version number; qstat command failed: $!";
	
	# Read in just the _first_ line of the qstat -help output.
	# This line will contain our version string.
	my ($version_string) = $qstatdata->getline;
	
	&captureInfo( $capture_idx, $version_string ) if $CAPTURE_FILE;

	$qstatdata->close;
	
	# For the moment, we don't care whether we're running SGEEE or just 
	# SGE.  (Indeed, the Enterprise Edition was discontinued as of SGE 6.)
	# Extract _just_ the version number.
	if ($version_string =~ /^\S+\s(\S+)$/) {
		return $1;
	}
	else {
		# Uh-oh.  The version string (if that is, indeed, what we're 
		# looking at) doesn't appear to follow the format we expect.  
		# This suggests that either something has gone wrong _or_ 
		# we're talking to a new version of SGE that doesn't follow our
		# expected conventions.  Abort.
		die "Version string '$version_string' does not follow the " .
		    "expected format of 'NAME VERSION' -- Aborting!\n" .
		    "This script probably needs to be updated!"
	}
}

# The purpose of this function is to inspect the local cluster installation and
# extract various cluster-wide details from it, including the cluster version
# number and site-wide policy.  
#
# Individual psuedo-queues may also impose additional constraints; however, we are 
# not looking for those details here. (See also lookupVirtualQueuePolicy())

sub lookupGlobalPolicy($) {
	my ($clusterref) = shift;	# Reference to %cluster hash.
	
	# We know we're running SGE, but lookup the version.
	$clusterref->{"global"}{"GlueCEInfoLRMSType"} 		= "sge";
	$clusterref->{"global"}{"GlueCEInfoLRMSVersion"} 	= lookupSGEVersion();

	# Lookup global MaxTotalJobs setting.
	# This corresponds to the "max_jobs" configuration value in SGE.
	# TODO: We should also consider "max_u_jobs"
	my $qconfdata = new IO::Pipe;

	my ( @command ) = ( $CONFIG{'qconf_command'}, '-sconf' );

	$qconfdata->reader( @command )
		or die "Unable to lookup queue policy with qconf: $!";
	
	my $capture_idx = &setupCaptureInfo( 'pipe', @command ) if $CAPTURE_FILE;

	while ( defined( $_ = $qconfdata->getline ) ) {
		&captureInfo( $capture_idx, $_ ) if $CAPTURE_FILE;

		# If line contains only whitespace, skip.
		if (/^\s*$/) { next; }
		
		# Parse the key and value from the output
		my ($key, $value) = split;

		if ($key eq "max_jobs") {
			# We've found the max job count.
			chomp $value;
			$clusterref->{"global"}{"GlueCEPolicyMaxTotalJobs"} = $value;
			last;
		}
	}
	$qconfdata->close;
}

# Look-up the current state of the local SGE cluster and update our
# cluster model.  We obtain a full list of:
#
# Jobs:
# for each job, we store its current status flags, the number of
# slots it will occupy when running, the job's hard requirements,
# and (if the job is running) lookup when the job started and calcuate
# (based on the job's hard wallclock limit, if any) how much longer
# the job has left to run.
#
# Batch nodes:
# For each batch node, we lookup the name of every job queue available
# on that node, the current state flags of every such queue and the number 
# of job slots that that queue provides.

sub lookupClusterState($$) {
	my ($clusterref,$queueref) = @_;

	# The format of the QSTAT output will differ depending on 
	# the version of SGE that we're interrogating.
	if ($clusterref->{"global"}{"GlueCEInfoLRMSVersion"} !~ /^6/) {
		die "Do not currently support SGE versions other than 6.x!";
	}

	# FIXME: Setup vopat for use by processjobs   (vopat is just a temporary hack)
	do {
		my %allvo;
		foreach my $qref ( values( %$queueref ) ) {
			foreach my $vo ( @{$qref->{"volist"}} ) {
				$allvo{$vo}++;
			}
		}
		
		$clusterref->{"vopat"} = join( "|", map( "\Q$_", keys %allvo ) );
#		warn "vopat=\"", $clusterref->{"vopat"}, "\"\n";
	};
	
	# Now obtain the full set of queue data.

	# NOTE:  Use of "-q" should be avoided as in SGE 6.0u9 at least,  it doesn't seem to
	#        show any information about jobs that have not yet started running (and 
	#        therefore haven't yet been assigned to a specific SGE queue-instance)
        # NOTE2: "slots" is included in preparation for better counting of jobslots
	# NOTE3: At some point we might want to add "-g t" so that we get more accurate
	#        information about the specific queue-instances involved in running parallel jobs
	my $qstatdata = new IO::Pipe;

	my ( @command ) = ( $CONFIG{'qstat_command'}, '-xml', '-u', '*', '-f', '-r', '-F' );
	push( @command, 'h_rt,s_rt,h_cpu,s_cpu,slots' ) unless $CAPTURE_FILE;

	$qstatdata->reader( @command )
		or die "Unable to get qstat output: $!\n";

	# If we are capturing data for debugging, then read the file into a string
	# Under normal circumstances we avoid this as the xml data can be very large
	if ( $CAPTURE_FILE ) {
		my $capture_idx = &setupCaptureInfo( 'pipe', @command );
		my $xmldata = '';
		while( defined( $_ = $qstatdata->getline ) ) {
			$xmldata .= $_;
			&captureInfo( $capture_idx, $_ );
		}
		$qstatdata->close;
		$qstatdata = $xmldata;
	}

	# We can now feed this scalar qstat data into XMLin to automagically
	# generate a datastructure for us.
	my $xmlref = XMLin( $qstatdata,
			    KeyAttr => { 'def_hard_request' => 'name',
					 'hard_request'     => 'name',
					 'soft_request'     => 'name',
					 'resource'         => 'name' },
			    ForceArray => [ 'Queue-List',
					    'def_hard_request', 
					    'hard_request', 
					    'soft_request',
					    'job_list',
					    'resource' ] );

	# When debugging info is being captured, $qstatdata is replaced by a string
	$qstatdata->close if ref($qstatdata);

	# Used for debugging.
#	print STDERR Dumper($xmlref)
#		if $DEBUG;

	# Generate a list of virtual queues
	my @virtualqueues = keys %{ $queueref };
	
	# Update the $clusterref datastructure with a set of hosts,
	# the queues available on each host, the number of slots used
	# and total and the state flags for that queue, if any.

	# Each the list of hash references which represent each queue.
	foreach (@{ $xmlref->{"queue_info"}{"Queue-List"} }) {
		my %q = %$_;
		my $q_name = $q{"name"};

		# Skip queues that we are not interested in
		# (and ignore any jobs running on those queues)
		
		# FIXME: Would it be better to only ignore the queues when calculating
		#        job & queue counts?

		next if defined( $CONFIG{'queue_include_regexp'} ) && ( $q_name !~ /$CONFIG{'queue_include_regexp'}/o );
		next if defined( $CONFIG{'queue_exclude_regexp'} ) && ( $q_name =~ /$CONFIG{'queue_exclude_regexp'}/o );

		# Split the queue name up into it's constituent parts.
		my ($hostq, $host);
		if ($q_name =~ /^(\S+)@(\S+)$/) {
			$hostq = $1;
			$host = $2;
		}
		else {
			die "Failed to split fully-qualified queuename $q_name into a queue\@hostname form.\n";
		}

		# Process any jobs running on this queue instance
		if ( defined $q{'job_list'} ) {
			foreach my $job ( @{ $q{'job_list'} } ) {
				&processJobDetails( $clusterref, $queueref, $job, $hostq, $host );
			}
		}

		# Lookup and record the numbers of used and total slots.
		$clusterref->{"hostq"}{"$host"}{"$hostq"}{"slotsused"} = $q{"slots_used"};
		$clusterref->{"hostq"}{"$host"}{"$hostq"}{"slotstotal"} = $q{"slots_total"};
		# Lookup state flags.
		if (defined $q{"state"}) {
			$clusterref->{"hostq"}{"$host"}{"$hostq"}{"flags"} = $q{"state"};
		}
		else {
			# If no state flags are defined, explicitly update our model with an empty-string.
			$clusterref->{"hostq"}{"$host"}{"$hostq"}{"flags"} = "";
		}
		
		my %resource;
		while ( my ( $k, $v ) = each %{$q{"resource"}} ) {
			$resource{$k} = ( ( $k =~ /^[hs]_(rt|cpu)$/ ) 
					  ? &timeValueToSeconds($v->{'content'})
					  : $v->{'content'} );
		}
		
		my ( $max_wall_time_s ) = &min_resource_value( $resource{'h_rt'}, $resource{'s_rt'} );
		my ( $max_cpu_time_s  ) = &min_resource_value( $resource{'h_cpu'}, $resource{'s_cpu'} );
		
		# max_wall_time & max_cpu_time resources are in minutes rather than seconds
		$resource{'max_wall_time'} = $max_wall_time_s / 60 if defined( $max_wall_time_s );
		$resource{'max_cpu_time'}  = $max_cpu_time_s  / 60 if defined( $max_cpu_time_s );
		$resource{'queue'}         = $hostq;
		
		$clusterref->{"hostq"}{$host}{$hostq}{"constraints"} = \%resource;

		my $maxruntime
			= ( defined( $max_wall_time_s )       ? $max_wall_time_s
			    :      defined( $max_cpu_time_s ) ? int( $max_cpu_time_s / $CONFIG{'job_efficiency'} )
			    :                                   $CONFIG{'default_duration'} );

		$clusterref->{"hostq"}{$host}{$hostq}{"maxruntime"} = $maxruntime;
		$clusterref->{"queue"}{$hostq}{"maxruntime"}        = $maxruntime
			unless defined( $clusterref->{"queue"}{$hostq}{"maxruntime"} )
			&&     defined( $maxruntime )
			&&     $maxruntime < $clusterref->{"queue"}{$hostq}{"maxruntime"};

		# Determine if jobs submitted in each virtual queue can be run using this queue_instance

		foreach my $vq ( @virtualqueues ) {
			next unless &satisfyConstraints( $queueref->{$vq}{"constraints"}, \%resource );

			$queueref->{$vq}{"hostqueue"}{$host}{$hostq} = 1;

			$queueref->{$vq}{"GlueValues"}{"GlueCEPolicyMaxWallClockTime"}
			= int( $resource{"max_wall_time"} )
				if defined( $resource{"max_wall_time"} )
				&& ( ! defined $queueref->{$vq}{"GlueValues"}{"GlueCEPolicyMaxWallClockTime"}
				     || $resource{"max_wall_time"} 
				     < $queueref->{$vq}{"GlueValues"}{"GlueCEPolicyMaxWallClockTime"} );

			$queueref->{$vq}{"GlueValues"}{"GlueCEPolicyMaxCPUTime"}
			= int( $resource{"max_cpu_time"} )
				if defined( $resource{"max_cpu_time"} )
				&& ( ! defined $queueref->{$vq}{"GlueValues"}{"GlueCEPolicyMaxCPUTime"}
				     || $resource{"max_cpu_time"} 
				     < $queueref->{$vq}{"GlueValues"}{"GlueCEPolicyMaxCPUTime"} );
		}
	}

	# Process any pending jobs that are not currently associated with a specific 
	# queue instance

	if ( defined $xmlref->{'job_info'}{'job_list'} ) {
		foreach my $job ( @{ $xmlref->{'job_info'}{'job_list'} } ) {
			&processJobDetails( $clusterref, $queueref, $job, undef, undef );
		}
	}
}

# Process details for a job
# Arguments:
#     $clusterref            - data structure representing cluster information
#     $queueref              - data structure representing virtual queues
#     $jobentry              - xml information about the job
#     $clusterqueue          - for running jobs... name of clusterqueue that is running the job, otherwise undef
#     $host                  - for running jobs... name of host that is running the job, otherwise undef
sub processJobDetails {
	my ( $clusterref, $queueref, $jobentry, $clusterqueue, $host ) = @_;
	
	my $currenttime = $TIME;

	my $jobid     = $jobentry->{"JB_job_number"};
	my $flags     = $jobentry->{"state"}->[1];
	my $starttime = $jobentry->{"JAT_start_time"};
	my $slotcount = $jobentry->{"slots"};	
	my $owner     = $jobentry->{"JB_owner"};
	my $taskcount = 1;

	return if defined( $CONFIG{'user_include_regexp'} ) && $owner !~ /$CONFIG{'user_include_regexp'}/o;
	return if defined( $CONFIG{'user_exclude_regexp'} ) && $owner =~ /$CONFIG{'user_exclude_regexp'}/o;

	# If the job isn't running, then we may still be able to determine $clusterqueue
	# by considering if "hard_req_queue" has been set
	
	# Tasks arrays are a comma seperated list where each element is one of:
	#       A    or    A-B:S
	# where:	A = start job id
	# 		B = end job id
	# 		S = step
	my $taskspec = $jobentry->{"tasks"};
	
	# If we are dealing with a job array:
	if (defined $taskspec) {
		# add the taskspec onto the jobid to make it unique
		#
		# (when each element of the job array starts running it gains its own
		#  qstat entry,  and the taskspec of the queued jobs is adjusted to
		#  remove the running task from the main qstat entry)
		$jobid .= ".$taskspec";
		
		# Calculate how many individual tasks this job array is equivalent to
		
		$taskcount = 0;
		
		foreach ( split( /,/, $taskspec ) ) {
			if ( /^(\d+)$/ ) {
				$taskcount++;
			} elsif ( /^(\d+)\-(\d+)\:(\d+)$/ 
				  && $1 <= $2 && $3 > 0 ) {
				$taskcount += int( ( $2 - $1 ) / $3 ) + 1;
			} else {
				warn "Failed to parse taskspec '$taskspec', assuming single task.";
				$taskcount++;
			}
		}
	}
	
	if ( $clusterref->{"job"}{$jobid} ) {
		# We already seem to have processed this job...   
		# It is probably a running parallel job so we should simply total up the slot count

		$clusterref->{"job"}{$jobid}{"slotcount"} += $slotcount;
		return;
	}
		
	my %resource;
	while ( my ( $k, $v ) = each %{$jobentry->{'def_hard_request'}} ) {
		$resource{$k} = $v->{'content'};
	}
	while ( my ( $k, $v ) = each %{$jobentry->{'soft_request'}} ) {
		$resource{$k} = $v->{'content'};
	}
	while ( my ( $k, $v ) = each %{$jobentry->{'hard_request'}} ) {
		$resource{$k} = $v->{'content'};
	}
	
	# FIXME: If more than one "hard_req_queue" is present, then they should be treated
	#        as valid alternatives....     we currently ignore the constraint instead

	if ( defined( $jobentry->{'hard_req_queue'} ) && ref( $jobentry->{'hard_req_queue'} ) ne 'ARRAY' ) {
		$resource{'queue'} = $jobentry->{'hard_req_queue'};
		$clusterqueue = $jobentry->{'hard_req_queue'} unless defined( $clusterqueue );
	}

	# Calculate max_wall_time by looking at h_rt & s_rt
	my $max_wall_time_s = &min_resource_value( $resource{'h_rt'}, $resource{'s_rt'} );
	
	# Calculate max_cpu_time by looking at h_cpu & s_cpu
	my $max_cpu_time_s  = &min_resource_value( $resource{'h_cpu'}, $resource{'s_cpu'} );

	$resource{'max_wall_time'} = $max_wall_time_s / 60 if defined( $max_wall_time_s );
	$resource{'max_cpu_time'}  = $max_cpu_time_s  / 60 if defined( $max_cpu_time_s );
		
	my $timeremaining_secs 
		= ( defined( $max_wall_time_s )       ? $max_wall_time_s
		    :      defined( $max_cpu_time_s ) ? int( $max_cpu_time_s * 60 / $CONFIG{'job_efficiency'} )
		    :                                   undef );

	$timeremaining_secs 
		= $clusterref->{"hostq"}{$host}{$clusterqueue}{"maxruntime"}
	        unless defined( $timeremaining_secs ) || ! defined( $clusterref ) || ! defined( $host );
	
	$timeremaining_secs
		= $clusterref->{"queue"}{$clusterqueue}{"maxruntime"}
	        unless defined( $timeremaining_secs ) || ! defined( $clusterqueue ) || ! defined( $clusterref );
	
	$timeremaining_secs = $CONFIG{'default_duration'}
	        unless defined( $timeremaining_secs );
	
	if ( $flags =~ /r/ ) {
		# If the job is currently running,  we need to deduct the amount of time
		# it has already been running from the remaining time

		# Convert the starttime into seconds since the unix epoch
		my $starttime_unix = &parse_date( $starttime );
		
		# Calculate how long the job has been running (in seconds)
		my $timespent_secs = $currenttime - $starttime_unix;
		
		# Deduct the amount of time the job has already been running
		$timeremaining_secs -= $timespent_secs;
		
		# If timeremaining is negative, then set to zero to avoid bogus estimates later
		# This can happen for multiple reasons including:
		# * It can take some time for SGE to kill jobs that have exceeded their limits
		# * We have no way of determining if a job might have been suspended
		# * The queuing system might have lost contact with the node running the job
		
		# FIXME:  If the job has significantly overrun,  we should perhaps
		#         guesstimate a remaining time value rather than use 0
		$timeremaining_secs = 0 if $timeremaining_secs < 0;
	} 

	# We have all our job data now, update our global data model.
	$clusterref->{"job"}{$jobid}{"slotcount"} 	 = $slotcount;
	$clusterref->{"job"}{$jobid}{"flags"} 		 = $flags;
	$clusterref->{"job"}{$jobid}{"starttime"} 	 = $starttime;
	$clusterref->{"job"}{$jobid}{"taskcount"}        = $taskcount;
	$clusterref->{"job"}{$jobid}{"timeleft"}         = $timeremaining_secs;
	$clusterref->{"job"}{$jobid}{"vo"} 		 = &lookup_vo_for_login( $clusterref, $owner );
	
	my @tmp;
	foreach my $vq ( keys %{$queueref} ) {
		# Jobs are considered to be members of all of the virtual queues whose
		# constraints they fit within
		next unless &satisfyConstraints( \%resource, $queueref->{$vq}{"constraints"} );

		$queueref->{$vq}{"jobs"}{$jobid} = 1;
		push( @tmp, $vq );
	}

	if ( $DEBUG ) {
		printf STDERR "%-10s %-12s %-6s %s\n", $jobid, $owner, ( $clusterref->{"job"}{$jobid}{"vo"} || '-' ), join(',',@tmp);
	}
}


# Min value
# Return the minimum (defined) value from all of the arguments
# This is called with resource values that can include "INFINITY"
sub min_resource_value {
	my $r;
	foreach ( @_ ) {
		$r = $_ if defined( $_ ) && ! /infinity/i && ( ! defined( $r ) || $_ < $r );
	}
	$r;
}

# This function's purpose is to parse the SGE JobManager virtual queue mapping 
# file and update our model of all externall-presented virtual queues.
# This configuration file specifies all of the hard constraints that are 
# imposed based on which virtual queue they requested.
# We need to know this information so that we can correctly classify concrete
# host queues and jobs so that, for each virtual queue, we can calculate the 
# number of running jobs, number of available slots, etc.

sub lookupVirtualQueuePolicy($) {
	my ($queueref) = shift;		# Reference to %queue hash

	# Load the JobManager virtual queue mapping file.
	# Each queue may appear more than once, each time specifying a 
	# different constraint.
	# (If the same field is specified more than once for a particular 
	# virtual queue then the results are undefined.)
	my $vqueuedata = new IO::File( $CONFIG{'vqueue_file'}, "r" )
		or die "Unable to open virtual queue mapping file.";

	my $capture_idx = &setupCaptureInfo( 'vqueues' ) if $CAPTURE_FILE;

	# For every line in the virtual queue map:
	while ( defined( $_ = $vqueuedata->getline ) ) {
		&captureInfo( $capture_idx, $_ ) if $CAPTURE_FILE;

		next if /^\s*\#/;       # Skip if comment
		next if /^\s*$/; 	# Skip if whitespace

		if (/^(\S+)\s+(\S+)\s+(\S+)/) {
			# If it's a constraint entry, extract the values.
			my ($queuename, $property, $value) = ($1, $2, $3);
			
			# If we know the queue exists (because it was defined in the LDIF file)
			if ((defined $queueref->{$queuename})) {
				# Add it to our model of constraints.
				# adjusting by a multiplicative factor where necessary
				$queueref->{$queuename}{"constraints"}{$property} = $value;
				
				# Also add it to our queue Glue dataset, if possible.
				my $gluename = $RSL_TO_GLUE{$property};
				if (defined( $gluename )) {
					$queueref->{$queuename}{"GlueValues"}{$gluename} 
					= ( defined( $RSL_TO_GLUE_MULTIPLIER{$property} )
					    ? int( $RSL_TO_GLUE_MULTIPLIER{$property} * $value )
					    : $value );
				}
			}
		} else {
			warn "Unrecognised entry in ".$CONFIG{'vqueue_file'}.": '$_'\n";
		}
	}	
	
	$vqueuedata->close;

	# At this point,  fill in a constraint of -q <queuename> for any queues that weren't
	# found in the virtual queue definitions

	foreach my $q ( keys %{$queueref} ) {
		$queueref->{$q}{"constraints"}{'queue'} = $q
			unless $queueref->{$q}{"constraints"};
	}
}


# The purpose of this function is to calculate the job counts for each
# virtual queue

# FIXME: As jobs can currently be associated with more than one virtual queue
#        the information reporter may give misleading impressions over the total
#        number of jobs that are queued/running etc
#        Needs further discussion to decide the best approach to take
#        (which might be different for job counts vs slot queues)
#        The current code uses the same approach as the version of the code I
#        inherited    - kms@doc.ic.ac.uk,  December 2006

sub calculateVirtualQueueJobCounts($$) {
	my ($clusterref, $queueref) = @_;
	
	# Generate a list of virtual queues
	my @virtualqueues = keys %{ $queueref };

	# Calculate the number of:
	#	* Running jobs in this queue
	#	* Queued jobs in this queue
	#	* The number of total slots in this queue (this requires clusterqueue data.)
	foreach my $queue (@virtualqueues) {
		my ($runningtotal, $queuedtotal, $slotstotal, $slotsenabled, $slotsused, $slotsfree) = (0,0,0,0,0);
		my (%vo_runningtotals, %vo_queuedtotals);
		# For every job:
		foreach my $job (keys %{ $queueref->{$queue}{"jobs"} }) {
			# If the job is in a running state, add it's slotcount to our total
			# number of running jobs.
			my $vo = $clusterref->{"job"}{$job}{"vo"};
			
			if ($clusterref->{"job"}{$job}{"flags"} =~ /r/) {
				$runningtotal++;
				$vo_runningtotals{$vo}++ if defined( $vo );
			} 
			# Otherwise, assuming the job is not in an error state,
			# add it's slotcount to our total number of queueing jobs.
			elsif ($clusterref->{"job"}{$job}{"flags"} !~ /E/) {
				$queuedtotal++;
				$vo_queuedtotals{$vo}++ if defined( $vo );
			}
		}
		# For every hostqueue that services a virtual queue
		foreach my $host ( keys %{ $queueref->{$queue}{"hostqueue"} }) {
			# Any given host queue on a host could service a job for the current virtual queue,
			# however it is entirely likely that each individual host queue is mutually exclusive.
			# For example, in LeSC, load threshold sensors are used to prevent more than N jobs
			# from being run simultaneously across *all* queues. (Where N is the number of 
			# processors on the host.)
			# However, we never know which particular queue might service a job.  
			# As a best-guess for what to report, find the queue with the *most* available slots that
			# isn't already disabled, and use that as our job-slot count for this virtual queue.

			# FIXME: Sometimes the number of slots being used is *bigger* than the number of total slots.
			#	 This is because we count _all_ of the job slots that a job is occupying,
			#	 not just those slots that should be considered for this virtual queue.
			# 	 We currently fudge this by setting an upper bound on the number of used slots
			#	 to be equal to the number of total slots.

			my $hostslotsfree    = 0;
			my $hostslotsused    = 0;
			my $hostslotstotal   = 0;
			my $hostslotsenabled = 0;

			# For every hostqueue on that host that might service this virtual queue
			# If that host is operational (ie has no error flags)
			my $hostq;
			foreach $hostq (keys %{ $queueref->{$queue}{"hostqueue"}{$host} }) {
				my $u = $clusterref->{"hostq"}{$host}{$hostq}{"slotsused"};
				my $t = $clusterref->{"hostq"}{$host}{$hostq}{"slotstotal"};
				my $f = $clusterref->{"hostq"}{$host}{$hostq}{"constraints"}->{"slots"} || 0;

				$hostslotsused += $u;
				$hostslotsfree = $f
					if ( $clusterref->{"hostq"}{$host}{$hostq}{"flags"} !~ /[aACdDEsu]/
					     && $f > $hostslotsfree );
				$hostslotsenabled = $t
					if ( $clusterref->{"hostq"}{$host}{$hostq}{"flags"} !~ /[aACdDEsu]/
					     && $t > $hostslotsenabled );
				$hostslotstotal = $t
					if $t > $hostslotstotal;
			}

			# Update our count of the total number of slots available.
			$slotsenabled += $hostslotsenabled;
			$slotstotal += $hostslotstotal;
			$slotsused += $hostslotsused;
			$slotsfree += $hostslotsfree;
		}

		# FUDGE: If runningtotal > slotstotal, set runningtotal = slotstotal.
		#	 (See FIXME explaination, above.)
		if ($runningtotal > $slotstotal) {
			$runningtotal = $slotstotal;
		}

                # FUDGE by Mona: If queuedtotal > 10,000, set queuedtotal = 100
                #my $max_queued_value = 10000;
                        #if ($queuedtotal > $max_queued_value) {      
                         #$queuedtotal = 100;         
                #}
                        

		# Now that we have calculated the various statistics for this virtual queue:
		# Update our internal model:
		$queueref->{$queue}{"freeslots"} = $slotsfree;
		$queueref->{$queue}{"totalslots"} = $slotsenabled;
		$queueref->{$queue}{"queuedjobs"} = $queuedtotal;
		# Record the different properties ready for writing out later.
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateRunningJobs"} = $runningtotal;
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateWaitingJobs"} = $queuedtotal;
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateTotalJobs"} = $runningtotal + $queuedtotal;

		# Foreach VO
		foreach my $vo ( @{$queueref->{$queue}->{"volist"}} ) {
			$queueref->{$queue}{"VO:GlueValues"}{$vo}{"GlueCEStateRunningJobs"} = $vo_runningtotals{$vo} || 0;
			$queueref->{$queue}{"VO:GlueValues"}{$vo}{"GlueCEStateWaitingJobs"} = $vo_queuedtotals{$vo} || 0;
			$queueref->{$queue}{"VO:GlueValues"}{$vo}{"GlueCEStateTotalJobs"}   = ( $vo_runningtotals{$vo} || 0 ) + ( $vo_queuedtotals{$vo} || 0 );
		}

		# We cannot simply use "$slotstotal - $runningtotal" because some slots may be used by jobs
		# that do not fall into this logical job set.
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateFreeJobSlots"} = $slotsfree;

		# FIXME: We use our existing slot counts as our reported CPU figure.
		$queueref->{$queue}{"GlueValues"}{"GlueCEPolicyMaxRunningJobs"} = $slotstotal;
		$queueref->{$queue}{"GlueValues"}{"GlueCEInfoTotalCPUs"} = $slotstotal;
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateFreeCPUs"} = $slotsfree;

		# Record the queue's current status.
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateStatus"} = $clusterstate;
	}
}

# The purpose of this function is to calculate the Estimated Response Time and
# Worst Case Reponse Time for each externally-presented virtual queue.
# This is comparatively easy because we've already worked out by this stage
# which of the cluster's hostqueues and jobs are logically considered to associated.
# with each virtual queue.
#
# FIXME:  However... for these calculations we should perhaps consider all jobs
#         associated with the hosts on which the virtual queue is associated rather
#         than just the jobs associated with the virtual queue
#         The most common scenario where this would be significant is if seperate
#         cluster queues have been setup for each VO.    If there are no jobs
#         currently submitted from the VO, then the number of jobs in its queue
#         would be zero,  however the system may have large queues for all of the
#         other VOs.
#     
# (Note that any given job and any given host queue can be associated with several
#  different virtual queues simultaneously!)

sub calculateResponseEstimate($$) {
	my ($clusterref, $queueref )= @_;

	# For every queue, 
	foreach my $queue ( keys %{ $queueref }) {
		# Calculate the total amount of wallclock time remaining in 
		# _all_ the jobs currently queued and running.
		# If the job is a multi-slot job, multiply its value by the number 
		# of slots it is using.
		# Then divide this by the total number of slots that serve this queue.
		# All values are in seconds.

		# For every job logically considered to be queued or running in this
		# queue:
		my $runtime_secs = 0;
		foreach my $job ( keys %{ $queueref->{$queue}{"jobs"} } ) {
			# Jobs which are in an error state are considered not to exist for the purposes
			# of response-time calculations.
			if ($clusterref->{"job"}{$job}{"flags"} !~ /E/) {
			        # Need to multiply by the number of tasks that this queue entry might represent
				$runtime_secs += ( $clusterref->{"job"}{$job}{"timeleft"}
						  * $clusterref->{"job"}{$job}{"slotcount"}
						  * $clusterref->{"job"}{$job}{"taskcount"});
			}
		}

		# If the number of slots total is zero, put in the largest 
		# possible waiting time.
		my $worst_waittime_secs;
		if ($queueref->{$queue}{"totalslots"} == 0) {
			$worst_waittime_secs = $MAX_INT32; 	# Glue value is an int32, return MAX_INT.
		} else {
			# Otherwise, if the number of unused slots is non-zero and there are no jobs currently
			# queued then the worst-case waiting time is zero.
			# (We check for the number of queued jobs as a safety feature!)
			if (($queueref->{$queue}{"freeslots"} > 0) &&
			    ($queueref->{$queue}{"queuedjobs"} == 0)) {
				$worst_waittime_secs = 0;
			}
			else {
				# Otherwise, the job will have to wait for all of the jobs ahead of it to complete.
				# Report the running total wallclock time / number of total slots.
				$worst_waittime_secs = $runtime_secs / $queueref->{$queue}{"totalslots"};
			}
		}
		
		# Calculate the average case time.  This is the worstcase time / 2.
		my $avg_waittime_secs = $worst_waittime_secs / 2;

		# Update the queue datastructure with our newly calculated values.
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateWorstResponseTime"} = int($worst_waittime_secs);
		$queueref->{$queue}{"GlueValues"}{"GlueCEStateEstimatedResponseTime"} = int($avg_waittime_secs);
	}
}

# Return false if any of the constraints requested by the job cannot be met by the
# resources offered by this queue
sub satisfyConstraints {
	my ( $job, $queue ) = @_;

	foreach my $c ( keys %{$job} ) {
		my $sub = $CONSTRAINTS{$c};

		return 0 if defined( $sub ) && ! &$sub( $job->{$c}, $queue->{$c} );
	}

	return 1;
}

# Time constraints are satisfied if
# either the queue doesn't impose a time constraint
# or     the time requested by the job is <= limit imposed on the queue
sub checkTimeConstraint {
	my ( $job, $queue ) = @_;

	( ! defined $queue ) || $job <= $queue;
}

# FIXME:  This doesn't currently handle all of the different combinations of patterns
#         that might occur...    and currently assumes that only clusterqueues are used
#      
#         We should really take into account queue-instances as well    (though for
#         full support this will require calls to qconf to expand hostgroups!)
#
#         It also assumes that only one queue is requested using "-q" whereas qsub
#         actually allows multiple "-q" options to allow alternatives to be requested
#
# FIXME:  Should fail gracefully if the queue constraints aren't supported
#         (probably by assuming that the constraint is satisfied)
sub checkQueueConstraint {
	my ( $job, $queue ) = @_;

	die "unsupported queue constraint: \"job\""
		if defined ( $job ) && $job =~ /[\*\@\?]/ && $job ne '*';
	die "unsupported queue constraint: \"queue\""
		if defined ( $queue ) && $queue =~ /[\*\@\?]/ && $queue ne '*';

	( ! defined $queue ) || ( $job eq '*' ) || ( $queue eq '*' ) || ( $job eq $queue );
}

# Convert time based resources into seconds
#
# "infinity" is represented by MAXINT
# The return value is verified to make sure that it doesn't exceed this value
sub timeValueToSeconds($) {
	my ($value) = @_;
	my $result =
		( ( $value =~ /^(\d+):(\d+):(\d+)$/ )            ? (($1 * 60) + $2) * 60 + $3              # hours:mins:seconds
		  : ( $value =~ /^(\d+)\:(\d+)\:(\d+)\:(\d+)$/ ) ? ((($1 * 24) + $2) * 60 + $3) * 60 + $4  # days:hours:mins:seconds
		  : ( $value =~ /^(\d+)\:(\d+)$/ )               ? ($1 * 60) + $2                          # mins:seconds
		  : ( $value =~ /^infinity$/i )                  ? $MAX_INT32
		  : ( $value =~ /^none$/i )                      ? undef
		  :                                                $value );

	$result = $MAX_INT32 if defined( $result ) && $result > $MAX_INT32;
	$result;
}

# Convert login name to a VO

sub lookup_vo_for_login {
	my ( $clusterref, $login ) = @_;

	my $vo = $VO_FROM_LOGIN{$login};

	return $vo if defined( $vo );
	
	if ( my @pw = &{$GETPWNAM}($login) ) {
		# We have found the user in the passwd file

		if ( my ( $group ) = &{$GETGRGID}($pw[3]) ) {
			if ( ! defined( $vo = $VO_FROM_GROUP{$group} ) ) {
				my $VOPAT = $clusterref->{"vopat"};
				$vo = $VO_FROM_GROUP{$group} = $3
					if $group =~ /^(\w+\-)?(sgm|prd)?($VOPAT)(sgm|prd)?\d*$/o;
			}
		}
	}

	$VO_FROM_LOGIN{$login} = $vo if defined( $vo );

	$vo;
}

sub getpwnam_sys { getpwnam(@_); }
sub getgrgid_sys { getgrgid(@_); }

sub getpwnam_fake { @{$LOGINS{$_[0]}}; };
sub getgrgid_fake { @{$GROUPS{$_[0]}}; };

sub populate_fake {
	my ( $hash, $filename, $i ) = @_;
	
	if ( open( FILE, $filename ) ) {
		while ( <FILE> ) {
			chomp;
			my ( @v ) = split( /\:/, $_ );
			$hash->{$v[$i]} = \@v if ! defined( $hash->{$v[$i]} );
		}
		close( FILE );
	}
}
	
# --- Main program ------------------------------------------------------

# We have already processed our command line and config file by the
# time we reach here

# Cluster state model; eg:
#
# $cluster{"global"}{ 	
# 	"GlueCEInfoLRMSType" => "sge",
#	"GlueCEInfoLRMSVersion" => "6.0u1"	
#       "GlueCEPolicyMaxTotalJobs" => 123,
# }
# $cluster{"hostq"}{"mars100.mars.lesc.doc.ic.ac.uk"}{ 
#	debug => { flags = "d", 
#		   slotsused = 0,
#		   slotstotal = 2,
#                  constraints = {} },
#	i240 => { flags = "",
#		  slotsused = 2,
#		  slotstotal = 2,
#                 constraints = {} }
# }
# $cluster{"job"}{"97500"}{ 
#	"slotcount" => 16,
#       "taskcount" => 1,
#	"flags" => "r",
#	"starttime" => "11/02/2005 11:07:00",     # date format varies between versions of SGE
#	"timeleft" => 5321
# }
# $cluster{"queue"}{"s072"}{
#       "max_time" => 1234                        # seconds
#
my (%cluster);

# Model of external virtual queue(s); eg:
#
# $queue{"10min"} = { 
# 	dn => ....
#       volist => [ atlas, biomed, dteam ],
#	constraints => { h_rt => "1" }	 		
#	GlueValues => { 
#		GlueCEInfoLRMSType => "sge",
#		GlueCGInfoLRMSVersion => "6.0u1" 
#	},
#	jobs => { "97500" => 1 },
#	hostqueue => { mars100.mars.lesc.doc.ic.ac.uk => { debug => 1, i240 => 1 } }
#	totalslots => 147,
#	freeslots => 0,
#	queuedjobs => 57
# }
#
my (%queue);

# Obtain a list of the DNs that we need to provide information for
my (@dn) = lookupDNs($CONFIG{'ldif_file'}, \%queue);

# Lookup cluster-global state and policy information.
lookupGlobalPolicy(\%cluster);

# Lookup virtual queue policy information.
lookupVirtualQueuePolicy(\%queue);

# Lookup cluster state information (host, job details).
# and assign host queues & jobs to virtual queues
lookupClusterState(\%cluster,\%queue);

# Calculate which job logically belongs to each virtual queue.
calculateVirtualQueueJobCounts(\%cluster, \%queue);

# Calculate queue response time estimates.
calculateResponseEstimate(\%cluster, \%queue);

# All information collected; output it in the expected form.
#
# eg:
# 	dn: GlueCEUniqueID=mars-ce.mars.lesc.doc.ic.ac.uk:2119/jobmanager-sge-short, mds-vo-name=local,o=Grid
#	GlueCEInfoLRMSType: sge
#	GlueCEInfoLRMSVersion: 6.0u1
#	...
#

# For debugging only.
#print STDERR Dumper(\%cluster)
#	if $DEBUG;
#print STDERR Dumper(\%queue)
#	if $DEBUG;

# Fill in some default values
foreach my $queue ( keys %queue ) {
	# Copy global values
	foreach ( keys( %{$cluster{"global"}} ) ) {
		$queue{$queue}{"GlueValues"}{$_} = $cluster{"global"}{$_} unless defined $queue{$queue}{"GlueValues"}{$_};
	}
 	# If neither the virtual queue file or queus have set CPU time limits,
	# then the value set elsewhere will be derived from the maximum job duration
	#
	# If users specify a max_cpu_time without a suitable max_wall_time, then this
	# may lead to frequent occurances where jobs are assigned to unsuitable queues
	#
	# Limit this problem by noting that there is no point in accepting jobs that
	# have a greater cpu-time limit than the maximum wall-clock time
	# (at least not for single-threaded/single-cpu jobs)
	
	$queue{$queue}{"GlueValues"}{"GlueCEPolicyMaxCPUTime"}
	= $queue{$queue}{"GlueValues"}{"GlueCEPolicyMaxWallClockTime"}
	if ( ! defined $queue{$queue}{"GlueValues"}{"GlueCEPolicyMaxCPUTime"} )
		|| ( defined( $queue{$queue}{"GlueValues"}{"GlueCEPolicyMaxWallClockTime"} )
		     && ( $queue{$queue}{"GlueValues"}{"GlueCEPolicyMaxWallClockTime"}
			  < $queue{$queue}{"GlueValues"}{"GlueCEPolicyMaxCPUTime"} ) );
}

# For every DN that we are interested in:
foreach ( @dn ) {
	my ( $dn, $queue, $vo ) = @{$_};
	my $gluevalues = $queue{$queue}{"GlueValues"};
	my $vo_gluevalues = $queue{$queue}{"VO:GlueValues"};

	# Print out the expected DN leading field.
	printf( "dn: %s\n", $dn );

	if ( defined( $vo ) ) {
		foreach ( @VO_INTERESTING_KEYS ) {
			my $fmt = $NUMERIC_KEYS{$_} ? "%s: %d\n" : "%s: %s\n";

			if ( defined( $vo_gluevalues->{$vo}->{$_} ) ) {
				printf( $fmt, $_, $vo_gluevalues->{$vo}->{$_} );
			} elsif ( defined( $gluevalues->{$_} ) ) {
				printf( $fmt, $_, $gluevalues->{$_} );
			}
		}
	} else {
		# Print out values.
		foreach ( sort keys %{$gluevalues} ) {
			my $fmt = $NUMERIC_KEYS{$_} ? "%s: %d\n" : "%s: %s\n";
			printf $fmt, $_, $gluevalues->{$_};
		}
	}

	print "\n";
}


# Local Variables:
#   perl-indent-level: 8
#   perl-continued-statement-offset: 8
#   perl-continued-brace-offset: 0
#   perl-brace-offset: -8
#   perl-brace-imaginary-offset: 0
#   perl-label-offset: -8
# End:
